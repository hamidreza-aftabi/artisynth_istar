package artisynth.istar.reconstruction;

import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;

import artisynth.core.modelbase.ComponentList;
import maspack.collision.IntersectionContour;
import maspack.collision.SurfaceMeshIntersector;
import maspack.geometry.Face;
import maspack.geometry.HalfEdge;
import maspack.geometry.MeshFactory;
import maspack.geometry.Polygon2d;
import maspack.geometry.Polygon3d;
import maspack.geometry.PolygonIntersector;
import maspack.geometry.PolygonalMesh;
import maspack.geometry.PolylineMesh;
import maspack.geometry.Vertex2d;
import maspack.geometry.Vertex3d;
import maspack.interpolation.NumericList;
import maspack.interpolation.NumericListKnot;
import maspack.matrix.Matrix2d;
import maspack.matrix.Plane;
import maspack.matrix.Point2d;
import maspack.matrix.Point3d;
import maspack.matrix.RigidTransform3d;
import maspack.matrix.Vector2d;
import maspack.matrix.Vector3d;
import maspack.matrix.VectorNd;
import maspack.numerics.PolynomialFit;
import maspack.util.DynamicDoubleArray;
import maspack.util.DynamicIntArray;
import maspack.util.InternalErrorException;

/**
 * Generic functions used in creating reconstruction objects.
 */
public class ComputeUtils {

   private static double INF = Double.POSITIVE_INFINITY;
   private static double RTOD = 180/Math.PI;

   /**
    * Compute the radius of an intersection contour about its centroid.
    */
   public static double computeContourRadius (
      IntersectionContour contour, Point3d cent) {
      double radius = 0;
      for (Point3d pnt : contour) {
         double r = pnt.distance(cent);
         if (r > radius) {
            radius = r;
         }
      }
      return radius;
   }

   /**
    * Create a specialized three segment clipping mesh, consisting of left and
    * right planes and a trim plane. These three planes are collectively
    * intersected by the planes y = w/2, y = -w/2, and x = -w/2, where w is the
    * nominal width of the mesh.
    *
    * This intersection produces three faces of a distorted cube with 8
    * vertices. We first compute the vertex coordinates, and the use
    * interpolation create the intermediate vertices which are mapped onto the
    * vertices of a rectangular triangular mesh.
    */
   public static PolygonalMesh createThreeSegmentClipMesh (
      Plane[] planes, double w, int res,
      boolean trimPlaneOnTop, boolean fillBack) {

      Plane planeL = planes[0];
      Plane planeR = planes[1];
      Plane planeT = planes[2];

      Point3d[] vtxs = new Point3d[8];
      for (int i=0; i<vtxs.length; i++) {
         vtxs[i] = new Point3d();
      }

      double xop;
      double yop;
      if (trimPlaneOnTop) {
         xop = -w/2;
         yop = w/2;
      }
      else {
         xop = w/2;
         yop = -w/2;
      }
      

      // points 0, 1, 2, 3 are arranged counter-clockwise around x and are the
      // intersection of the left and right resection planes with the lines
      // (xop,yop,0)+s(0,0,1) and (xop,-yop,0)+s(0,0,1)
      Point3d pnt = new Point3d();
      Vector3d dir = new Vector3d();
      dir.set (Vector3d.Z_UNIT);
      pnt.set (xop, yop, 0);
      double s0 = planeR.intersectLine (vtxs[0], dir, pnt);
      double s1 = planeL.intersectLine (vtxs[1], dir, pnt);
      if (s0 == INF || s1 == INF || s0 >= s1) {
         System.out.printf ("createClipMesh failed: s0=%g s1=%g\n", s0, s1);
         return null;
      }
      pnt.set (xop, -yop, 0);
      double s2 = planeL.intersectLine (vtxs[2], dir, pnt);
      double s3 = planeR.intersectLine (vtxs[3], dir, pnt);
      if (s2 == INF || s3 == INF || s2 <= s3) {
         System.out.printf ("createClipMesh failed: s2=%g s3=%g\n", s2, s3);
         return null;
      }
      
      // points 4, 5, 6, 7 are arranged counter-clockwise around x and are the
      // intersection of the left and right resection planes with the lines
      // generated by intersecting the trim plane with y = yop and y = -yop.
      Plane yplane = new Plane (Vector3d.Y_UNIT, yop);
      if (!planeT.intersectPlane (pnt, dir, yplane)) {
         System.out.printf (
            "createClipMesh failed: planeT doesn't intersect planey");
         return null;
      }
      if (dir.z < 0) {
         dir.negate();
      }
      double s4 = planeR.intersectLine (vtxs[4], dir, pnt);
      double s5 = planeL.intersectLine (vtxs[5], dir, pnt);
      if (s4 == INF || s5 == INF || s4 >= s5) {
         System.out.printf ("createClipMesh failed: s4=%g s5=%g\n", s4, s5);
         return null;
      }
      yplane.setOffset (-yop);
      if (!planeT.intersectPlane (pnt, dir, yplane)) {
         System.out.printf (
            "createClipMesh failed: planeT doesn't intersect -planey");
         return null;
      }
      if (dir.z < 0) {
         dir.negate();
      }
      double s6 = planeL.intersectLine (vtxs[6], dir, pnt);
      double s7 = planeR.intersectLine (vtxs[7], dir, pnt);
      if (s6 == INF || s7 == INF || s6 <= s7) {
         System.out.printf ("createClipMesh failed : s6=%g s7=%g\n", s6, s7);
         return null;
      }
      
      // now find the resolutions 
      double lenR =
         Math.max(vtxs[0].distance(vtxs[4]), vtxs[3].distance(vtxs[7]));
      double lenT =
         Math.max(vtxs[4].distance(vtxs[5]), vtxs[6].distance(vtxs[7]));
      double lenL =
         Math.max(vtxs[1].distance(vtxs[5]), vtxs[2].distance(vtxs[6]));
      int ny = res;
      int nR = (int)Math.ceil(res/w*lenR);      
      int nT = (int)Math.ceil(res/w*lenT);
      int nL = (int)Math.ceil(res/w*lenL);      
      if (fillBack) {
         // nR and nL need to be the same
         nL = nR = Math.max (nR, nL);
      }
      int nx = nR+nT+nL;

      PolygonalMesh clipMesh =
         MeshFactory.createRectangle (1.0, w, nx, ny, false);

      // mesh rectangle contains (nx+1)*(ny+1) vertices, increasing along the x
      // axis and then the y axis, such that if i and j are the x and y vertex
      // indices, the overall index k is k = j*(nx+1)+i.
      
      // reassign the x and z vertex values
      Point3d p0 = new Point3d();
      Point3d p1 = new Point3d();
      Point3d p4 = new Point3d();
      Point3d p5 = new Point3d();
      for (int j=0; j<=ny; j++) {
         double s = j/(double)ny;
         p0.combine (1-s, vtxs[3], s, vtxs[0]);
         p4.combine (1-s, vtxs[7], s, vtxs[4]);
         p5.combine (1-s, vtxs[6], s, vtxs[5]);
         p1.combine (1-s, vtxs[2], s, vtxs[1]);
         for (int i=0; i<=nx; i++) {
            Point3d pos = new Point3d();
            if (i <= nR) {
               double t = i/(double)nR;
               pos.combine (1-t, p0, t, p4);
            }
            else if (i <= nR+nT) {
               double t = (i-nR)/(double)nT;
               pos.combine (1-t, p4, t, p5);
            }
            else {
               double t = (i-nR-nT)/(double)nL;
               pos.combine (1-t, p5, t, p1);
            }
            clipMesh.getVertex(j*(nx+1)+i).setPosition (pos);
         }
      }
      clipMesh.notifyVertexPositionsModified();

      if (fillBack) {

         // gether vertex indices for the back, creating the vertices if
         // needed.
         int[] vidxs = new int[(nR+1)*(nT+1)];
         Point3d pos = new Point3d();
         for (int j=0; j<=nR; j++) {
            int vidxR = nR-j;
            int vidxL = nx-(nR-j);
            int vidx;
            for (int i=0; i<=nT; i++) {
               if (j == 0) {
                  vidx = vidxR + i;
               }
               else if (i == 0) {
                  vidx = vidxR;
               }
               else if (i == nT) {
                  vidx = vidxL;
               }
               else {
                  Point3d pR = clipMesh.getVertex(vidxR).getPosition();
                  Point3d pL = clipMesh.getVertex(vidxL).getPosition();
                  double t = i/(double)nT;
                  pos.combine (1-t, pR, t, pL);
                  vidx = clipMesh.numVertices();
                  clipMesh.addVertex (pos);
               }
               vidxs[j*(nT+1)+i] = vidx;
            }
         }
         // add faces to fill the back
         for (int j=0; j<nR; j++) {
            for (int i=0; i<nT; i++) {
               int v00 = vidxs[j*(nT+1)+i];
               int v10 = vidxs[j*(nT+1)+i+1];
               int v01 = vidxs[(j+1)*(nT+1)+i];
               int v11 = vidxs[(j+1)*(nT+1)+i+1];
               clipMesh.addFace (v00, v11, v10);
               clipMesh.addFace (v00, v01, v11);
            }
         }
      }
      return clipMesh;
   }  

   /**
    * Finds the longest, closed, intersection contour between mesh0 and mesh1.
    * Returns {@code null} if no closed contour exists.
    */
   public static IntersectionContour findPrimaryIsectContour (
      PolygonalMesh mesh0, PolygonalMesh mesh1) {

      SurfaceMeshIntersector intersector = new SurfaceMeshIntersector();
      ArrayList<IntersectionContour> contours =
         intersector.findContours (mesh0, mesh1);
      double maxl = -1;
      IntersectionContour maxc = null;
      for (IntersectionContour c : contours) {
         if (c.isClosed()) {
            double l = c.computeLength();
            if (l > maxl) {
               maxc = c;
               maxl = l;
            }
         }
      }
      return maxc;
   }

   /**
    * Finds the closed intersection contour between mesh0 and mesh1.
    * Returns {@code null} if no closed contour exists.
    */
   public static ArrayList<IntersectionContour> findClosedIsectContours (
      PolygonalMesh mesh0, PolygonalMesh mesh1) {

      SurfaceMeshIntersector intersector = new SurfaceMeshIntersector();
      ArrayList<IntersectionContour> contours =
         intersector.findContours (mesh0, mesh1);
      ArrayList<IntersectionContour> closedContours =
         new ArrayList<>(contours.size());

      for (IntersectionContour c : contours) {
         if (c.isClosed()) {
            closedContours.add (c);
         }
      }
      return closedContours;
   }

   /**
    * Cpmputes the intersection area between two contours projected in a plane.
    *
    * @param c0 first intersection contour
    * @param c1 second intersection contour
    * @param TPW transform from plane to world coordinates
    * @return intersection area
    */
   public static double computeIntersectionArea (
      IntersectionContour c0, IntersectionContour c1, RigidTransform3d TPW) {

      Polygon3d poly0 = new Polygon3d (c0);
      Polygon3d poly1 = new Polygon3d (c1);

      Polygon3d[] isect = PolygonIntersector.intersect (poly0, poly1, TPW);
      double area = 0;
      for (int i=0; i<isect.length; i++) {
         area += isect[i].computePlanarArea();
      }
      return area;
   }

   /**
    * Estimate the surface normal at the mesh location nearest to a prescribed
    * postion.
    *
    * @param pos prescribed position, in world coordinates
    * @param mesh mesh for which surface is to be estimated
    * @return estimated normal, in world coordinates
    */
   public static Vector3d estimateSurfaceNormal (
      Point3d pos, PolygonalMesh mesh) {
      // find the face and uv coordinates of the mesh point nearest to pos:
      Vector2d uv = new Vector2d();
      Face face = mesh.nearestFaceToPoint (null, uv, pos);
      // compute the normal as the sum of the face vertex normals, weighted by
      // the barycentric coordinates
      Vector3d nrm = new Vector3d();
      Vector3d vnrm = new Vector3d();
      Vertex3d[] vtxs = face.getVertices();
      if (vtxs.length != 3) {
         throw new InternalErrorException (
            "Body mesh is not triangular");
      }
      vtxs[0].computeWorldNormal (vnrm);
      nrm.scale (1-uv.x-uv.y, vnrm);
      vtxs[1].computeWorldNormal (vnrm);      
      nrm.scaledAdd (uv.x, vnrm);
      vtxs[2].computeWorldNormal (vnrm);      
      nrm.scaledAdd (uv.y, vnrm);
      nrm.normalize();
      return nrm;
   }

   /**
    * Estimate the surface normal at the mesh location nearest to a prescribed
    * postion. The estimate is performed using all neighbouring mesh vertices
    * within a prescribed distance.
    *
    * @param pos prescribed position, in world coordinates
    * @param mesh mesh for which surface is to be estimated
    * @param dist distance tolerance for neighbouring mesh vertices
    * @return estimated normal, in world coordinates
    */
   public static Vector3d estimateSurfaceNormal (
      Point3d pos, PolygonalMesh mesh, double dist) {
      // find the face and uv coordinates of the mesh point nearest to pos:
      Vector2d uv = new Vector2d();
      Point3d near = new Point3d();
      Face face = mesh.nearestFaceToPoint (near, uv, pos);
      HashSet<Vertex3d> nearVtxs = new LinkedHashSet<>();
      ArrayDeque<Vertex3d> queue = new ArrayDeque<>();
      for (Vertex3d vtx : face.getVertices()) {
         nearVtxs.add (vtx);
         queue.add (vtx);
      }
      while (queue.size() > 0) {
         Vertex3d vtx = queue.remove();
         Iterator<HalfEdge> it = vtx.getIncidentHalfEdges();
         while (it.hasNext()) {
            Vertex3d v = it.next().getTail();
            if (v.distance (near) < dist && !nearVtxs.contains(v)) {
               nearVtxs.add (v);
               queue.add (v);
            }
         }
      }

      ArrayList<Point3d> pnts = new ArrayList<>(nearVtxs.size());
      for (Vertex3d vtx : nearVtxs) {
         pnts.add (vtx.getPosition());
      }
      Plane plane = new Plane();
      plane.fit (pnts);
      if (plane.getNormal().dot (face.getNormal()) < 0) {
         plane.flip();
      }
      return plane.getNormal();
   }

   /**
    * Estimate the contact ratio of mesh A with respect to mesh B and a given
    * plane. A contact ratio is the overlap ratio in the range [0, 1], where 1
    * indicates optimal overlap.
    *
    * TPW describes the pose of the plane separating the two bodies, with the z
    * axis denoting the plane normal, which is assumed to be directed away from
    * mesh A and towards mesh B.
    *
    * @param meshA mesh to check for overlap
    * @param meshB mesh to check for overlap against
    * @param TPW transform of the plane, in world coordinates, with the z axis
    * defining the plane normal facing away from A towards B.
    * @param mesh0 if non-null, is used to store the slice mesh formed by
    * subracting the plane half-space from meshA
    * @param mesh1 if non-null, is used to store the slice mesh formed by
    * intersecting an extension of meshA with meshB
    * @param cutWidth width of the plane mesh used to cut meshA
    * @param cutWRes resolution of the plane mesh used to cut meshA
    * @deprecated Use {@link #estimateContactRatio3D(PolygonalMesh,PolygonalMesh,RigidTransform3d,double,int,PolygonalMesh,PolygonalMesh)} instead
    * 
    */
   static double estimateContactRatio3D (
      PolygonalMesh meshA, PolygonalMesh meshB, RigidTransform3d TPW,
      PolygonalMesh mesh0, PolygonalMesh mesh1,
      double cutWidth, int cutRes) {
         return estimateContactRatio3D (
            meshA, meshB, TPW, cutWidth, cutRes, mesh0, mesh1);
      }

   /**
    * Estimate the contact ratio of mesh A with respect to mesh B and a given
    * plane. A contact ratio is the overlap ratio in the range [0, 1], where 1
    * indicates optimal overlap.
    *
    * TPW describes the pose of the plane separating the two bodies, with the z
    * axis denoting the plane normal, which is assumed to be directed away from
    * mesh A and towards mesh B.
    *
    * <p>The method works in 3D by intersecting meshA and meshB with thin
    * slices that are aligned with the plane, finding the overlap between the
    * resulting intersections, and computing ratios of the resulting volumes.
    * This approach was used prior to the development of
    * {@link #estimateContactRatios2D(PolygonalMesh,,,,,,)}.
    *
    * @param meshA mesh to check for overlap
    * @param meshB mesh to check for overlap against
    * @param TPW transform of the plane, in world coordinates, with the z axis
    * defining the plane normal facing away from A towards B.
    * @param cutWidth width of the plane mesh used to cut meshA
    * @param smeshA if non-null, is used to store the slice mesh formed by
    * subracting the plane half-space from meshA
    * @param smeshI if non-null, is used to store the slice mesh formed by
    * intersecting an extension of meshA with meshB
    * @param cutWRes resolution of the plane mesh used to cut meshA
    */
   static double estimateContactRatio3D (
      PolygonalMesh meshA, PolygonalMesh meshB, RigidTransform3d TPW,
      double cutWidth, int cutRes,
      PolygonalMesh smeshA, PolygonalMesh smeshI) {
      
      // Overlap is estimated by intersecting the meshes with a thin plate
      // centered on the plane, and then doing CSG operations on the results.
      // The input meshes are extended on either side of the plane to ensure
      // the operations work correctly.

      double h = 1e-1; // plate thickness
      double tol = 1e-6; // tolerance for extending meshes around the planes

      // prepare the meshes by copying them and extending them in the
      // directions of the resection planes:
      Plane plane;
      meshA = meshA.clone();
      plane = new Plane (TPW);
      int num = extendVerticesNearPlane (meshA, plane, h, tol);

      // create the thin plates for CSG ops. Plates have different thicknesses
      // to avoid degeneracies when we overlap them.
      PolygonalMesh cutPlane = MeshFactory.createPlane (
         cutWidth, cutWidth, cutRes, cutRes);
      SurfaceMeshIntersector smi = new SurfaceMeshIntersector();

      cutPlane.setMeshToWorld (TPW);
      PolygonalMesh slice0 = smi.findDifference01 (meshA, cutPlane);
      double vol0 = slice0.computeVolume();
      if (smeshA != null) {
         smeshA.addMesh (slice0, /*respectTransforms=*/true);
      }

      PolygonalMesh slice1 = smi.findIntersection (meshA, meshB);
      double voli = slice1.computeVolume();
      if (smeshI != null) {
         smeshI.addMesh (slice1, /*respectTransforms=*/true);
      }
      return voli/vol0;
   }

   static void addContoursToMesh (
      PolylineMesh mesh, ArrayList<IntersectionContour> contours) {

      int voff = 0;
      for (IntersectionContour c : contours) {
         int[] idxs = new int[c.size()+1];
         int k = 0;
         for (Point3d p : c) {
            mesh.addVertex (new Vertex3d (new Point3d(p)));
            idxs[k] = voff+k;
            k++;
         }
         idxs[k] = voff;
         mesh.addLine (idxs);
         voff += c.size();
      }
   }

   static void addContourIntersectionsToMesh (
      PolylineMesh mesh,
      IntersectionContour c0, IntersectionContour c1, RigidTransform3d TPW) {

      Polygon3d poly0 = new Polygon3d (c0);
      Polygon3d poly1 = new Polygon3d (c1);

      Polygon3d[] isect = PolygonIntersector.intersect (poly0, poly1, TPW);
      int voff = 0;
      for (Polygon3d poly : isect) {
         Point3d[] pnts = poly.getPoints();
         int[] idxs = new int[pnts.length+1];
         int k = 0;
         for (Point3d p : pnts) {
            mesh.addVertex (new Vertex3d (new Point3d(p)));
            idxs[k] = voff+k;
            k++;
         }
         idxs[k] = voff;
         mesh.addLine (idxs);
         voff += pnts.length;
      }
   }

   /**
    * Estimate the contact ratios for two meshes with respect to a given
    * plane. The intersection of meshA and meshB with the plane produces two
    * closed polygons: polyA and polyB. Let polyI denote the intersection of
    * polyA and polyA. Then the contact ratios for A and B are given by
    * <pre>
    * rA = area(polyI)/area(polyA)
    * rB = area(polyI)/area(polyB)
    * </pre>
    * The contact ratio for meshA is then the fraction of A that is covered by
    * the overlap, and likewise for meshB. Each ratio must be in the range [0,
    * 1], where 1 indicates optimal overlap.
    *
    * TPW describes the pose of the plane separating the two bodies, with the z
    * axis denoting the plane normal, which is assumed to be directed away from
    * mesh A and towards mesh B.
    *
    * <p>The method works by first finding the closed interection contours of
    * meshA and meshB with the plane. These contours are then intersected
    * pairwise and the pair with the largest intersection area is used to
    * determine the contact ratios.
    * 
    * @param meshA mesh to check for overlap
    * @param meshB mesh to check for overlap against
    * @param TPW transform of the plane, in world coordinates, with the z axis
    * defining the plane normal facing away from A towards B.
    * @param cutWidth width of the plane mesh used to cut meshA
    * @param cutWRes resolution of the plane mesh used to cut meshA
    * @param cmeshA if non-null, the intersection contours of meshA with
    * the plane are added to this mesh as polylines
    * @param cmeshB if non-null, the intersection contours of meshB with
    * the plane are added to this mesh as polylines
    * @param cmeshI if non-null, the polygonal interection of the closed meshA
    * and meshB contours is added to this mesh as polylines
    * @return contact ratios [rA, rB].
    */
   static double[] estimateContactRatios2D (
      PolygonalMesh meshA, PolygonalMesh meshB,
      RigidTransform3d TPW, double cutWidth, int cutRes,
      PolylineMesh cmeshA, PolylineMesh cmeshB, PolylineMesh cmeshI) {
      
      // distance for placing the intersect plane on either side of the mesh
      double h = 1e-4; 

      PolygonalMesh cutPlane =
         MeshFactory.createPlane (cutWidth, cutWidth, cutRes, cutRes);
      SurfaceMeshIntersector smi = new SurfaceMeshIntersector();

      RigidTransform3d TCW = new RigidTransform3d(TPW);
      TCW.mulXyz (0, 0, -h);
      cutPlane.setMeshToWorld (TCW);
      ArrayList<IntersectionContour> contours0 =
         findClosedIsectContours (meshA, cutPlane);

      if (cmeshA != null) {
         addContoursToMesh (cmeshA, contours0);
      }

      TCW.mulXyz (0, 0, 2*h);
      cutPlane.setMeshToWorld (TCW);
      ArrayList<IntersectionContour> contours1 =
         findClosedIsectContours (meshB, cutPlane);

      if (cmeshB != null) {
         addContoursToMesh (cmeshB, contours1);
      }

      // find the closed contour pair with the max intersection
      double maxArea = 0;
      IntersectionContour cmax0 = null;
      IntersectionContour cmax1 = null;
      for (IntersectionContour c0 : contours0) {
         for (IntersectionContour c1 : contours1) {
            double a = computeIntersectionArea (c0, c1, TPW);
            if (a > maxArea) {
               cmax0 = c0;
               cmax1 = c1;
               maxArea = a;
            }
         }
      }

      double[] ratios = new double[2];
      if (maxArea > 0) {
         double area0 = cmax0.computePlanarArea();
         double area1 = cmax1.computePlanarArea();
         double areai = maxArea;

         if (cmeshI != null) {
            addContourIntersectionsToMesh (cmeshI, cmax0, cmax1, TPW);
         }
         ratios[0] = areai/area0;
         ratios[1] = areai/area1;
      }
      return ratios;
   }

   /**
    * Estimates the contact ratios at each junction between the donor segments
    * and left and right mandible resections. The contact is returned as an
    * overlap ratio in the range [0, 1], where 1 indicates optimal overlap.
    *
    * <p>The method works in 3D by checking the overlap between polyhedra
    * formed by interecting the resection and/or donor meshes with thin slices
    * aligned with the contact place. It was used prior to the development of
    * {@link #estimateContactRatios2D(ComponentList,,)}.
    *
    * <p> Ratios are computed left-to-right and it is assumed that the segments
    * are ordered in this was as well. Two ratios are computed at each junction
    * between bodies A and B: the amount for A covered by B and the amount of B
    * covered by A.
    */
   static double[] estimateContactRatios3D (
      ComponentList<DonorSegmentBody> segments, 
      PolygonalMesh mandibleL, PolygonalMesh mandibleR) {

      int nsegs = segments.size();

      // Overlap is estimated by intersecting the meshes with a thin plate
      // centered on the plane, and then doing CSG operations on the results.
      // The input meshes are extended on either side of the plane to ensure
      // the operations work correctly.

      double h = 1e-1; // plate thickness
      double tol = 1e-8; // tolerance for extending meshes around the planes

      // prepare the left and right mandible meshes by copying them and
      // extending them in the directions of the resection planes:
      Plane plane;
      mandibleL = mandibleL.clone();
      plane = segments.get(0).getPlaneM(0); // left resection plane
      plane.inverseTransform (mandibleL.getMeshToWorld());         
      int num = extendVerticesNearPlane (mandibleL, plane, 1.5*h, tol);
      mandibleR = mandibleR.clone();
      plane = segments.get(nsegs-1).getPlaneM(1); // right resection plane
      plane.inverseTransform (mandibleR.getMeshToWorld());         
      extendVerticesNearPlane (mandibleR, plane, 1.5*h, tol);

      // create the thin plates for CSG ops. Plates have different thicknesses
      // to avoid degeneracies when we overlap them.
      PolygonalMesh cutPlate0 =
         MeshFactory.createBox (90, 90, h, new Point3d(), 30, 30, 1);
      PolygonalMesh cutPlate1 =
         MeshFactory.createBox (90, 90, 2*h, new Point3d(), 30, 30, 1);
      SurfaceMeshIntersector intersector = new SurfaceMeshIntersector();

      // Compute the ratios associated with each segment. Segments run from
      // left to right.
      double[] ratios = new double[2*(nsegs+1)];
      PolygonalMesh mesh0 = mandibleL;
      for (int i=0; i<nsegs; i++) {
         DonorSegmentBody seg = segments.get(i);
         PolygonalMesh mesh1 = seg.createExtendedMesh (1.5*h, tol);
         cutPlate0.setMeshToWorld (seg.getTPW_M(0));
         PolygonalMesh slice0 = intersector.findIntersection (mesh0, cutPlate0);
         double vol0 = slice0.computeVolume();
         cutPlate1.setMeshToWorld (seg.getTPW_M(0));
         PolygonalMesh slice1 = intersector.findIntersection (mesh1, cutPlate1);
         // divide volume of slice1 since it is twice as thick
         double vol1 = slice1.computeVolume()/2;
         
         PolygonalMesh isect = intersector.findIntersection (slice0, slice1);
         double voli = isect.computeVolume();

         ratios[2*i + 0] = voli/vol0;
         ratios[2*i + 1] = voli/vol1;
         mesh0 = mesh1;         
      }
      // handle right mandible
      cutPlate0.setMeshToWorld (segments.get(nsegs-1).getTPW_M(1));
      PolygonalMesh slice0 = intersector.findIntersection (mesh0, cutPlate0);
      double vol0 = slice0.computeVolume();

      cutPlate1.setMeshToWorld (segments.get(nsegs-1).getTPW_M(1));
      PolygonalMesh slice1 = intersector.findIntersection (mandibleR, cutPlate1);
      double vol1 = slice1.computeVolume()/2;

      PolygonalMesh isect = intersector.findIntersection (slice0, slice1);
      double voli = isect.computeVolume();
 
      ratios[ratios.length-2] = voli/vol0;
      ratios[ratios.length-1] = voli/vol1;
      return ratios;
   }


   /**
    * Estimates the contact ratios at each junction between the donor segments
    * and left and right mandible resections. The contact is returned as an
    * overlap ratio in the range [0, 1], where 1 indicates optimal overlap.
    *
    * <p>The method works in 2D by checking the overlap between the planar
    * polygons formed by interecting the resection and/or donor meshes with
    * each contact plane.
    *
    * <p> Ratios are computed left-to-right and it is assumed that the segments
    * are ordered in this was as well. Two ratios are computed at each junction
    * between bodies A and B: the amount for A covered by B and the amount of B
    * covered by A.
    */
   static double[] estimateContactRatios2D (
      ComponentList<DonorSegmentBody> segments, 
      PolygonalMesh mandibleL, PolygonalMesh mandibleR) {

      int nsegs = segments.size();

      double width = 90;
      int res = 30;

      // Compute the ratios associated with each segment. Segments run from
      // left to right.
      double[] ratios = new double[2*(nsegs+1)];
      PolygonalMesh mesh0 = mandibleL;
      for (int i=0; i<nsegs; i++) {
         DonorSegmentBody seg = segments.get(i);
         PolygonalMesh mesh1 = seg.getMesh();
         
         double[] cr = estimateContactRatios2D (
            mesh0, mesh1, seg.getTPW_M(0), width, res, null, null, null);

         ratios[2*i + 0] = cr[0];
         ratios[2*i + 1] = cr[1];
         mesh0 = mesh1;         
      }
      // handle right mandible

      
      double[] cr = estimateContactRatios2D (
         mandibleR, mesh0, segments.get(nsegs-1).getTPW_M(1), width, res,
         null, null, null);

      ratios[ratios.length-2] = cr[1];
      ratios[ratios.length-1] = cr[0];
      return ratios;
   }

   /**
    * Extends the vertices of a mesh lying on (or near) a plane by a specified
    * amount in the direction of the plane normal. This is used to avoid
    * degeneracies associated with CSG operations on meshes that have
    * previously been cut by the plane. Note that the mesh is modified in
    * place.
    *
    * <p>The plane is assumed to be given in mesh local coordinates.
    *
    * @param mesh mesh to extend
    * @param plane plane sround which to extend the mesh
    * @param ext amount to extend the vertices by
    * @param tol distance tolerance within which points are considered
    * to be on the plane
    * @return number of extended vertices
    */
   static int extendVerticesNearPlane (
      PolygonalMesh mesh, Plane plane, double ext, double tol) {
      int num = 0;
      Point3d pos = new Point3d();
      for (Vertex3d vtx : mesh.getVertices()) {
         pos.set (vtx.getPosition());
         if (Math.abs(plane.distance(pos)) <= tol) {
            pos.scaledAdd (ext, plane.getNormal());
            num++;
         }
         vtx.setPosition (pos);
      }
      mesh.notifyVertexPositionsModified();
      return num;
   }

   /**
    * Computes the one-sided Hausdorf 95 distance between two meshes.
    */
   static public double get3DHandedHausdorff95 (
      PolygonalMesh A, PolygonalMesh B) {
      ArrayList<Vertex3d> verticesA = A.getVertices ();
      ArrayList<Vertex3d> verticesB = B.getVertices ();
      double[] h = new double[verticesA.size ()];
      
      for (int i = 0; i < verticesA.size (); i++) {
         h[i] = B.distanceToPoint (verticesA.get(i).getPosition());
      }
      Arrays.sort (h);
      return h[(int)(0.95 * verticesA.size())];
   }

   /**
    * Computes the Hausdorf 95 distance between two meshes.
    */
  static public double get3DHausdorff95 (PolygonalMesh A, PolygonalMesh B) {
     double h1 = get3DHandedHausdorff95 (A, B);
     double h2 = get3DHandedHausdorff95 (B, A);
     
     if (h1 > h2) {
        return h1;
     } 
     else {
        return h2;
     }
  }

   /**
    * Estimates the volume overlap between two meshes, returning the result as
    * a ratio in the range [0,1].
    */
   static public double getVolumeOverlap(PolygonalMesh A, PolygonalMesh B) {
      if(A.equals (B)) {
         return 1.0;
      }
      
      double volume1 = A.computeVolume ();
      double volume2 = B.computeVolume ();
      PolygonalMesh intersectionMesh = new PolygonalMesh();
      SurfaceMeshIntersector intersector = new SurfaceMeshIntersector();
      intersectionMesh = intersector.findIntersection(A,B);
      if(intersectionMesh == null) {
         return 0.0;
      }
      double intersectionVol = intersectionMesh.computeVolume ();
      double simIndex = (2*intersectionVol) / (volume1 + volume2);
      return simIndex;
   }

   /**
    * Remeshes a mesh using cross sections along a the z axis of the frame
    * defined by TFW. To work properly, the shape of the input mesh cross
    * sections must be fairly similar along the axis.
    */
   static public PolygonalMesh remeshByCrossSection (
      PolygonalMesh mesh, RigidTransform3d TFW,
      double zmargin, int nlen, int nsec, double xextendfactor) {

      // get bounds of the mesh wrt F
      Vector3d pmin = new Vector3d();
      Vector3d pmax = new Vector3d();
      mesh.computeWorldBounds (pmin, pmax, TFW);
      double xysize = Math.hypot (pmax.x-pmin.x, pmax.y-pmin.y);
      double xextend = xextendfactor*(pmax.x-pmin.x);

      Vector3d axisZ = new Vector3d();
      TFW.R.getColumn (2, axisZ);

      PolygonalMesh section = MeshFactory.createPlane (2*xysize, 2*xysize);

      PolygonalMesh newmesh = new PolygonalMesh();
      RigidTransform3d TSW = new RigidTransform3d(TFW);
      // create nlen+1 cross sections between pmin.z and pmax.z, shrinking by
      // 10% to provide clearance at the ends
      ArrayList<Vertex3d> vtxs0 = null; // new vertices for current cross section
      ArrayList<Vertex3d> vtxs1 = null; // new vertides for previous cross section

      pmin.z += zmargin;
      pmax.z -= zmargin;
      
      for (int i=0; i<=nlen; i++) {
         double s = i/(double)nlen;
         double l = pmin.z*(1-s)+pmax.z*s;
         TSW.p.scaledAdd (l, axisZ, TFW.p);
         section.setMeshToWorld (TSW);
         IntersectionContour contour = findPrimaryIsectContour (mesh, section);
         if (contour == null) {
            throw new IllegalArgumentException (
               "no intersection contour detected at i=" + i + ", l=" + l);
         }
         // create new vertices uniformly sampled around the contour
         vtxs1 = createUniformVertices (contour, TSW, nsec, xysize, xextend);
         if (vtxs1 == null) {
            throw new IllegalArgumentException (
               "intersection contour at i=" + i +
               " does not intersect positive x axis properly");
         }
         if (i == 0) {
            Point3d cent = new Point3d();
            contour.computeCentroid (cent);
            Vertex3d vend = newmesh.addVertex (cent);
            for (Vertex3d v : vtxs1) {
               newmesh.addVertex (v);
            }
            // add end faces
            for (int j=0; j<nsec; j++) {
               int jnext = (j+1)%nsec;
               newmesh.addFace (vend, vtxs1.get(j), vtxs1.get(jnext));
            }
         }
         else {
            for (Vertex3d v : vtxs1) {
               newmesh.addVertex (v);
            }
            // add side faces
            for (int j=0; j<nsec; j++) {
               int jnext = (j+1)%nsec;
               newmesh.addFace (vtxs0.get(j), vtxs1.get(j), vtxs1.get(jnext));
               newmesh.addFace (vtxs0.get(j), vtxs1.get(jnext), vtxs0.get(jnext));
            }
         }
         if (i == nlen) {
            Point3d cent = new Point3d();
            contour.computeCentroid (cent);
            Vertex3d vend = newmesh.addVertex (cent);
            // add end faces
            for (int j=0; j<nsec; j++) {
               int jnext = (j+1)%nsec;
               newmesh.addFace (vend, vtxs1.get(jnext), vtxs1.get(j));
            }
         }
         vtxs0 = vtxs1;
      }
      return newmesh;
   }

   /**
    * Computes the intersection parameters (t, v) between two line segments,
    * where t and u given the position along each line segment according to
    * <pre>
    * p0 + t (p1-p0),  // first segment
    * p2 + u (p3-p2)   // second segment
    * </pre>
    * The segments are deemed to intersect if they are not parallel and
    * if u and t are in [0,1]. If these conditions are not met, the method
    * returns null.
    */
   static private double[] intersectSegments (
      Point2d p0, Point2d p1, Point2d p2, Point2d p3) {
      Vector2d u01 = new Vector2d();
      Vector2d u23 = new Vector2d();
      Vector2d u02 = new Vector2d();
      u01.sub (p1, p0);
      u23.sub (p3, p2);
      u02.sub (p2, p0);

      double denom = u01.cross(u23);
      double numt = u02.cross(u23);
      double numu = u02.cross(u01);

      // t = numt/denom and u = numu/denom.
      if (denom == 0) {
         // segments are parallel
         return null;
      }
      if (numt*denom < 0 || numu*denom < 0 ||
          Math.abs(numt) > Math.abs(denom) || Math.abs(numu) > Math.abs(denom)) {
         // intersection does not lie on both segments
         return null;
      }
      return new double[] { numt/denom, numu/denom };
   }

   static private ArrayList<Vertex3d> createUniformVertices (
      IntersectionContour contour, RigidTransform3d TSW,
      int nsec, double xysize, double xextend) {

      ArrayList<Vertex3d> vtxs = new ArrayList<>();

      // map the contour into a 2d polygon in the x-y plane of TSW
      Polygon2d poly = new Polygon2d (contour, TSW);
      Point2d cent = new Point2d();
      poly.getCentroid (cent);

      Vertex2d v0 = poly.getFirstVertex();
      Vertex2d v = v0;
      Vertex2d vstart = null;
      double tstart = 0;
      double lsec;
      int nvtxs;

      if (xextend > 0) {
         // resample the vertices that occur clockwise between those
         // with the maximum and minimum values
         Vertex2d vmax = null;
         Vertex2d vmin = null;
         double ymax = -INF;
         double ymin = INF;

         do {
            Vertex2d vnext = v.getNext();
            Point2d pnt = v.getPosition();
            if (pnt.y > ymax) {
               ymax = pnt.y;
               vmax = v;
            }
            if (pnt.y < ymin) {
               ymin = pnt.y;
               vmin = v;
            }
            v = vnext;
         }
         while (v != v0);
         // find length between vmax and vmax
         double len = 0;
         for (v=vmin; v != vmax; v = v.getNext()) {
            len += v.distance(v.getNext());
         }
         vstart = vmin;
         tstart = 0;
         nvtxs = nsec-2;
         lsec = len/(nvtxs-1);
      }
      else {
         // resample entrie contour, starting at the point is crosses
         // the positive x axis
         Point2d xmax = new Point2d(cent);
         xmax.x += xysize;
         do {
            Vertex2d vnext = v.getNext();
            double[] isec = 
               intersectSegments (
                  v.getPosition(), vnext.getPosition(), cent, xmax);
            if (isec != null) {
               if (vstart == null) {
                  vstart = v;
                  tstart = isec[0];
               }
               else {
                  // shouldn't have more than one intersection
                  return null;
               }
            }
            v = vnext;
         }
         while (v != v0);
         if (vstart == null) {
            return null;
         }
         nvtxs = nsec;
         lsec = contour.computeLength()/nsec;
      }
      
      v = vstart;
      double t = tstart;
      Point2d pos2 = new Point2d();
      do {
         pos2.combine (1-t, v.getPosition(), t, v.getNext().getPosition());
         Point3d pos = new Point3d (pos2.x, pos2.y, 0);
         pos.transform (TSW);
         vtxs.add (new Vertex3d (pos));
         // now advance (v,t) along the contour by lsec
         double l = 0;
         do {
            double d = v.distance (v.getNext());
            double ldiff = (1-t)*d; // change in l going to next vertex
            if (l+ldiff > lsec) {
               // don't need to go to next vertex; adjust t
               t += (lsec-l)/d;
               l = lsec;
            }
            else {
               l += ldiff;
               t = 0;
               v = v.getNext();
            }
         }
         while (l < lsec);
      }
      while (vtxs.size() < nvtxs);
      if (xextend > 0) {
         Vertex2d vend = v;
         // add extending vertices along the xaxis
         Point3d pos = new Point3d (xextend, vend.getPosition().y, 0);
         pos.transform (TSW);
         vtxs.add (new Vertex3d (pos));
         pos = new Point3d (xextend, vstart.getPosition().y, 0);
         pos.transform (TSW);
         vtxs.add (new Vertex3d (pos));
      }
      return vtxs;
   }

   static void testIsect (
      double p0x, double p0y, double p1x, double p1y,
      double p2x, double p2y, double p3x, double p3y) {

      double[] tu = intersectSegments (
         new Point2d(p0x, p0y), 
         new Point2d(p1x, p1y), 
         new Point2d(p2x, p2y), 
         new Point2d(p3x, p3y));
      if (tu == null) {
         System.out.println ("null");
      }
      else {
         System.out.println ("l=" + tu[0] + " u=" + tu[1]);
      }
   }

   public static ArrayList<Point3d> findFibulaTop (
      PolygonalMesh clippedMesh, int npts) {

      Point3d pmin = new Point3d();
      Point3d pmax = new Point3d();
      clippedMesh.getWorldBounds (pmin, pmax);
      double margin = (pmax.z-pmin.z)*0.01;
      double minz = pmin.z + margin;
      double maxz = pmax.z - margin;

      double size = 2*Math.max (pmax.x-pmin.x, pmax.y-pmin.y);

      PolygonalMesh planeMesh =
         MeshFactory.createRectangle (size, size, 20, 20, false);
      
      ArrayList<Point3d> topPnts = new ArrayList<>();
      DynamicDoubleArray topAngles = new DynamicDoubleArray();
      for (int i=0; i<npts; i++) {
         double z = minz + i*(maxz-minz)/(npts-1);
         planeMesh.setMeshToWorld (new RigidTransform3d (0, 0, z));
         IntersectionContour contour =
            ComputeUtils.findPrimaryIsectContour (clippedMesh, planeMesh);
         if (contour != null) {
            Point3d pnt = new Point3d();
            topAngles.add (findTopPoint (pnt, contour, z));
            topPnts.add (pnt);
         }
      }
      // cluster the angles
      double ang0 = topAngles.get(0);
      double angA = 0;
      double angB = 0;
      int numA = 0;
      int numB = 0;
      for (int i=0; i<topAngles.size(); i++) {
         double ang = topAngles.get(i);
         if (angleDist (ang, ang0) < Math.PI/2) {
            angA += ang;
            numA++;
         }
         else { 
            angB += ang;
            numB++;
         }
      }
      angA /= numA;
      if (numB > 0) {
         angB /= numB;
      }
      // throw out pnts whose angles are far from the most common angle
      double topAng = numA > numB ? angA : angB;
      Iterator<Point3d> it = topPnts.iterator();
      int i = 0;
      int removeCnt = 0;
      while (it.hasNext()) {
         it.next();
         if (angleDist (topAngles.get(i), topAng) > Math.PI/2) {
            it.remove();
            removeCnt++;
         }
         i++;
      }
      return topPnts;
   }

   static double angleDist (double ang0, double ang1) {
      double dist = ang0-ang1;
      while (dist > Math.PI) {
         dist -= 2*Math.PI;
      }
      while (dist <= -Math.PI) {
         dist += 2*Math.PI;
      }
      return Math.abs(dist);
   }

   static double findTopPoint (
      Point3d top, IntersectionContour contour, double z) {
      Point2d centroid = new Point2d();
      Polygon2d curve = new Polygon2d (contour, RigidTransform3d.IDENTITY);
      curve.getCentroid (centroid);

      Vector2d moa1 = new Vector2d();
      Vector3d moa2 = new Vector3d();
      double area = curve.computeAreaIntegrals (moa1, moa2);
      Point2d com = new Point2d(moa1);
      com.scale (1/area);

      Matrix2d J = new Matrix2d();
      J.m00 = moa2.y;
      J.m11 = moa2.x;
      J.m01 = -moa2.z;

      J.m00 -= area*(com.y*com.y);
      J.m11 -= area*(com.x*com.x);
      J.m01 += area*(com.x*com.y);

      J.m10 = J.m01;

      // diagonalize explicitly
      double the = Math.atan2 (2*J.m01, J.m00-J.m11)/2;
      double s = Math.sin (the);
      double c = Math.cos (the);
      Matrix2d R = new Matrix2d (c, -s, s, c);
      Matrix2d D = new Matrix2d ();
      D.mulTransposeLeft (R, J);
      D.mul (R);

      // R gives the orientation of the diagonalized frame
      Vector2d axis = new Vector2d();
      double ang;
      if (D.m00 < D.m11) {
         // x axis is main one
         ang = the;
         R.getColumn (0, axis);
      }
      else {
         // y axis is main one
         ang = the + Math.PI/2;
         if (ang > 2*Math.PI) {
            ang -= 2*Math.PI;
         }
         R.getColumn (1, axis);
      }
      // intersect the contour with a ray along the axis passing through
      // the centroid
      Point2d ipos = curve.intersectRay (com, axis);
      axis.negate();
      Point2d ineg = curve.intersectRay (com, axis);
      if (ipos.distance (com) > ineg.distance (com)) {
         // direction to flat part is along the negative axis
         ang += (ang > Math.PI ? -Math.PI : Math.PI);
         top.set (ineg.x, ineg.y, z);
      }
      else {
         axis.negate();
         top.set (ipos.x, ipos.y, z);
      }
      return ang;
   }

   public static ArrayList<Point3d> findFibulaRidge (
      PolygonalMesh clippedMesh, int npts) {

      Point3d pmin = new Point3d();
      Point3d pmax = new Point3d();
      clippedMesh.getWorldBounds (pmin, pmax);
      double margin = (pmax.z-pmin.z)*0.01;
      double minz = pmin.z + margin;
      double maxz = pmax.z - margin;

      double size = 2*Math.max (pmax.x-pmin.x, pmax.y-pmin.y);

      PolygonalMesh planeMesh =
         MeshFactory.createRectangle (size, size, 20, 20, false);
      
      ArrayList<Point3d> ridgePnts = new ArrayList<>();
      for (int i=0; i<npts; i++) {
         double z = minz + i*(maxz-minz)/(npts-1);
         planeMesh.setMeshToWorld (new RigidTransform3d (0, 0, z));
         IntersectionContour contour =
            ComputeUtils.findPrimaryIsectContour (clippedMesh, planeMesh);
         Point3d pnt = null;
         if (contour != null) {
            pnt = findRidgePoint (contour, z);
            if (pnt != null) {
               ridgePnts.add (pnt);
            }
         }
      }
      return ridgePnts;
   }

   static Point3d findRidgePoint (IntersectionContour contour, double z) {
      Point2d centroid = new Point2d();
      Polygon2d curve = new Polygon2d (contour, RigidTransform3d.IDENTITY);
      curve.getCentroid (centroid);

      int WIN_SIZE = 21;

      NumericList nlist = new NumericList(1);
      for (int i=0; i<360+WIN_SIZE; i++) {
         double ang = Math.toRadians(i-WIN_SIZE/2);
         double s = Math.sin(ang);
         double c = Math.cos(ang);
         Vector2d u = new Vector2d (c, s);
         Point2d isect = curve.intersectRay (centroid, u);
         if (isect != null) {
            NumericListKnot knot = new NumericListKnot (1);
            knot.t = Math.toRadians((i-WIN_SIZE/2)); // angle
            knot.v.set(0, isect.distance (centroid)); // radius
            nlist.add (knot);
         }
         else {
            System.out.println ("MISSED at " + i);
         }
      }
      nlist.applySavitzkyGolaySmoothing (WIN_SIZE, 2);
      DynamicIntArray maxIdxs = new DynamicIntArray();
      DynamicDoubleArray maxCurvature = new DynamicDoubleArray();
      DynamicDoubleArray maxRadius = new DynamicDoubleArray();
      DynamicDoubleArray maxAngle = new DynamicDoubleArray();
      PolynomialFit fitter =
         new PolynomialFit (2, WIN_SIZE, -WIN_SIZE/50.0, WIN_SIZE/50.0);
      VectorNd coefs = new VectorNd (3);
      double[] yv = new double[WIN_SIZE];
      for (int i=WIN_SIZE/2; i<nlist.getNumKnots()-WIN_SIZE/2; i++) {
         double rprev = nlist.getKnot(i-1).v.get(0);
         double r = nlist.getKnot(i).v.get(0);
         double rnext = nlist.getKnot(i+1).v.get(0);
         if (rprev < r && rnext < r) {
            maxIdxs.add (i);
            for (int j=-WIN_SIZE/2; j<=WIN_SIZE/2; j++) {
               yv[j+WIN_SIZE/2] = nlist.getKnot(i+j).v.get(0);
            }
            fitter.fit (coefs, yv);
            maxCurvature.add (Math.abs(coefs.get(0)));
            maxRadius.add (r);
            maxAngle.add ((i-WIN_SIZE/2)/100.0);
         }
      }
      double maxc = maxCurvature.get(0);
      int maxcIdx = 0;
      double maxr = maxRadius.get(0);
      int maxrIdx = 0;
      for (int i=1; i<maxCurvature.size(); i++) {
         if (maxCurvature.get(i) > maxc) {
            maxc = maxCurvature.get(i);
            maxcIdx = i;            
         }
         if (maxRadius.get(i) > maxr) {
            maxr = maxRadius.get(i);
            maxrIdx = i;            
         }
      }
      if (maxrIdx == maxcIdx) {
         NumericListKnot knot = nlist.getKnot (maxIdxs.get(maxrIdx));
         double r = knot.v.get(0);
         double s = Math.sin (knot.t);
         double c = Math.cos (knot.t);
         return new Point3d (centroid.x+r*c, centroid.y+r*s, z);
      }
      else {
         return null;
      }
   }

   // public static Vector2d[] computePiecewiseLinearCoefs (Vector2d[][] pnts) {
   //    int nsegs = pnts.length;
   //    int npnts = 0;
   //    for (int idx=0; idx<pnts.length; idx++) {
   //       Vector2d[] segpnts = pnts[idx];
   //       if (segpnts.length == 0) {
   //          throw new IllegalArgumentException (
   //             "Segment "+idx+" has no points; at least one required");
   //       }
   //       npnts += segpnts.length;
   //    }
   //    if (npnts < nsegs+1) {
   //       throw new IllegalArgumentException (
   //          "Number of points is "+npnts+
   //          "; must exceed number of segments "+nsegs+" by one");
   //    }
   // }

   public static void main (String[] args) throws IOException {
      
      double eps = 1e-10;
      testIsect (0, 0, 1, 1, 0, 1, 1, 0);
      testIsect (0, 0, 1, 1, 1, 1, 2, 2);
      testIsect (0, 0, 0, 1, 0, 1, 1, 1);
      testIsect (0, 0, 0, 1, 1, 0, 2, 1);

      PolygonalMesh donor = new PolygonalMesh ("clippedDonor.obj");

      RigidTransform3d TMW = new RigidTransform3d();
      RigidTransform3d TFW = new RigidTransform3d();
      TFW.fromString (
         "[-0.830154 0.908442 32.472455 0.394721 -0.576775 -0.715211 6.669433]");
      TMW.fromString (
         "[-1.637513 -3.21142 -2.235986 0.043954 -0.011264 -0.99897 108.74642]");
      donor.setMeshToWorld (TMW);

      PolygonalMesh mesh = remeshByCrossSection (donor, TFW, 1.0, 20, 30, 2);
      mesh.inverseTransform (TFW);
      mesh.write ("remesh.obj");

      donor.transform (TMW);
      donor.inverseTransform (TFW);
      donor.write ("donor.obj");
   }
}

